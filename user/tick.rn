use json::*;
use rand::*;
use time::*;

fn test_stuff(state, bag) {
    let args = #{
        "target": bag.living().unwrap().key(),
        "tagged": #{
            "example": #{}
        }
    };

    let scheduling = actions::rune::rune(args)?;

    let state = match state {
        Some(state) => state,
        None => RuneState::new(),
    };

    [
        Some(state),

        actions::chat::speak(ActionArgs {
            here: Some("Whoa there!")
        })?,

        actions::scheduling::schedule(#{
            "entity": bag.item().unwrap().key(),
            "key": "TEST",
            "time": #{ "delay": 5000 },
            "action": scheduling
        })?
    ]
}

pub fn held(state, bag) {
    test_stuff(state, bag)
}

pub fn dropped(state, bag) {
    // info(format!("dropped {:?}", bag));
    // info(format!("dropped {:?} {:?}", bag.area(), bag.area().unwrap().name()));
    // info(format!("dropped {:?} {:?}", bag.living(), bag.living().unwrap().name()));
    // info(format!("dropped {:?} {:?}", bag.item(), bag.item().unwrap().name()));

    test_stuff(state, bag)
}

pub fn left(state, bag) {
    // info(format!("left"));
}

pub fn arrived(state, bag) {
    // info(format!("arrived"));
}

pub fn example(state, bag) {
    info(format!("example {:?}", bag));
}

pub fn actions() {
    #{
        "example": example,
    }
}

pub fn handlers() {
    #{
        "carrying": #{
            "held": held,
            "dropped": dropped
        },
        "moving": #{
            "left": left,
            "arrived": arrived
        }
    }
}

pub fn before(perform) {
    return Some(perform)
}

pub fn after(effect) {
    return effect;
}