use json::*;
use rand::*;
use time::*;

fn test_stuff(bag) {
    let args = #{
        "target": bag.living().unwrap().key(),
        "tagged": #{
            "example": #{}
        }
    };

    let scheduling = actions::rune::rune(args)?;

    [
        actions::chat::speak(ActionArgs {
            here: Some("Whoa there!")
        })?,

        actions::scheduling::schedule(#{
            "entity": bag.item().unwrap().key(),
            "key": "TEST",
            "time": #{ "delay": 5000 },
            "action": scheduling
        })?
    ]
}

pub fn held(bag) {
    test_stuff(bag)
}

pub fn dropped(bag) {
    // info(format!("dropped {:?}", bag));
    // info(format!("dropped {:?} {:?}", bag.area(), bag.area().unwrap().name()));
    // info(format!("dropped {:?} {:?}", bag.living(), bag.living().unwrap().name()));
    // info(format!("dropped {:?} {:?}", bag.item(), bag.item().unwrap().name()));

    test_stuff(bag)
}

pub fn left(bag) {
    // info(format!("left"));
}

pub fn arrived(bag) {
    // info(format!("arrived"));
}

pub fn example(bag) {
    info(format!("example {:?}", bag));
}

pub fn actions() {
    #{
        "example": example,
    }
}

pub fn handlers() {
    #{
        "carrying": #{
            "held": held,
            "dropped": dropped
        },
        "moving": #{
            "left": left,
            "arrived": arrived
        }
    }
}

pub fn before(perform) {
    return Some(perform)
}

pub fn after(effect) {
    return effect;
}